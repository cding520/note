[TOC]

## 一、类与对象

### 1.1、定义

- 类：对现实中事物的描述

- 对象：就是实实在在 存在的事物

  ​	对象的三个主要特性：

  - 对象的行为（behavior)—可以对对象施加哪些操作，或可以对对象施加哪些方法
  - 对象的状态 （state)—当施加那些方法时，对象如何响应
  - 对象标识（identity )—如何辨别具有相同行为与状态的不同对象

>  映射到Java中就是：事务的描述就是 `class` 定义的类；具体对象就是对应java在堆内存中new建立的实体

### 1.2、类之间的关系

- 依赖 （“ uses-a”）
- 聚合（“ has-a”）
- 继承（“ is-a”）  

![image-20201109203400802](https://gitee.com/icecandy/imgbed/raw/master/Java/20201109203402.png)

## 二、封装

### 2.1、定义

 封装（Encapsulation）就是把对象的属性和操作（或服务）结合为一个独立的整体，并尽可能隐藏对象的内部实现细节。

- 将类的某些信息隐藏在类的内部，不允许外部程序进行
- 直接的访问调用。
- 通过该类提供的方法来实现对隐藏信息的操作和访问。
- 隐藏对象的信息。
- 留出访问的对外接口。

### 2.2、特点

- 对成员变量实行更准确的控制。
- 封装可以隐藏内部程序实现的细节。
- 良好的封装能够减少代码之间的耦合度。
- 外部成员无法修改已封装好的程序代码。
- 方便数据检查，有利于保护对象信息的完整性，同时也提高程序的安全性。
- 便于修改，体高代码的可维护性。

### 2.3、使用

- 使用private修饰符，表示最小的访问权限。
- 对成员变量的访问，统一提供setXXX，getXXX方法。

示例，一个Student实体对象类：

```java
public class Student implements Serializable {
    
    private Long id;
    private String name;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
```

### 2.4、构造函数与默认构造函数

 构造函数，是一种特殊的方法。主要用来在创建对象时初始化对象，即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。特别的一个类可以有多个构造函数，可根据其参数个数的不同或参数类型的不同来区分它们即构造函数的重载。

 构造函数跟一般的实例方法十分相似；但是与其它方法不同，构造器没有返回类型，不会被继承，且可以有范围修饰符。构造器的函数名称必须和它所属的类的名称相同。 它承担着初始化对象数据成员的任务。

 如果在编写一个可实例化的类时没有专门编写构造函数，多数编程语言会自动生成缺省构造器（默认构造函数）。默认构造函数一般会把成员变量的值初始化为默认值，如int -> 0，Integer -> null。

### 2.5、命名规则

- 名称只能由字母、数字、下划线、$符号组成

- 命名时不能以数字开头
- 在命名是绝对不能出现Java关键字
- 绝对不允许在命名时出现中文及拼音命名
- java除了变量名以外，所有的实例，包括类，类常量，都采用大小写混合方式。

### 2.6、类变量、成员变量和局部变量

 Java中共有三种变量，分别是：

- **类变量**：用static修饰的变量称为静态变量，其内容被该类的所有对象共享，所有对象中这个类变量的值都指向相同的一处内存，随便一个对象修改了此处内存的值都会影响其他对象。存放在JVM的方法区。
- **成员变量**：在类定义时声明的变量，随着对象的建立而建立，随着对象的消失而消失。存放在JVM的堆内存。
- **局部变量**：函数中声明的变量，只定义在局部范围内，只在所属的区域有效。存放在JVM的栈内存。

```java
public class Variables {

        /**
         * 类变量
         */
        private static int a;

        /**
         * 成员变量
         */
        private int b;

        /**
         * 局部变量
         * @param c
         */
        public void test(int c){
            int d;
        }
    }
```

### 2.7、成员变量和方法作用域

 对于成员变量和方法的作用域，public，protected，private以及不写之间的区别：

- **public** : 表明该成员变量或者方法是对所有类或者对象都是可见的,所有类或者对象都可以直接访问
- **private** : 表明该成员变量或者方法是私有的,只有当前类对其具有访问权限,除此之外其他类或者对象都没有访问权限.子类也没有访问权限.
- **protected** : 表明成员变量或者方法对类自身,与同在一个包中的其他类可见,其他包下的类不可访问,除非是他的子类
- **default** : 表明该成员变量或者方法只有自己和其位于同一个包的内可见,其他包内的类不能访问,即便是它的子类

|    修饰符     | 类内部 | 本包 | 子类 | 外部包 |
| :-----------: | :----: | :--: | :--: | :----: |
|    public     |   √    |  √   |  √   |   √    |
|   protected   |   √    |  √   |  √   |   ×    |
| default(不写) |   √    |  √   |  ×   |   ×    |
|    private    |   √    |  ×   |  ×   |   ×    |

## 三、继承

### 3.1、概述

 继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。当然，如果在父类中拥有私有属性(private修饰)，则子类是不能被继承的。

### 3.2、特点

- 提高代码复用性。
- 父类的属性方法可以用于子类。
- 可以轻松的定义子类。
- 使设计应用程序变得简单。

### 3.3、注意事项

- 只支持单继承，即一个子类只允许有一个父类，但是可以实现多级继承，及子类拥有唯一的父类，而父类还可以再继承。
- 子类可以拥有父类的属性和方法。
- 子类可以拥有自己的属性和方法。
- 子类可以重写覆盖父类的方法。

### 3.4、继承与实现

 继承和实现都体现了传递性。而且明确定义如下：

- **继承**：如果多个类的某个部分的功能相同，那么可以抽象出一个类出来，把他们的相同部分都放到父类里，让他们都继承这个类。
- **实现**：如果多个类处理的目标是一样的，但是处理的方法方式不同，那么就定义一个接口，也就是一个标准，让他们的实现这个接口，各自实现自己具体的处理方法来处理那个目标

 所以，继承的根本原因是因为要复用，而实现的根本原因是需要定义一个标准。

 在Java中，`继承`使用`extends`关键字实现，而`实现`通过`implements`关键字。

 Java中支持一个类同时实现多个借口，但是不支持同时继承多个类，即：**单继承，多实现**。

> 简单点说，就是同样是一台汽车，既可以是电动车，也可以是汽油车，也可以是油电混合的，只要实现不同的标准就行了，但是一台车只能属于一个品牌，一个厂商。

```java
class Car extends Benz implements GasolineCar, ElectroCar{

}
```

 在接口中只能定义全局常量（static final）和无实现的方法（Java 8以后可以有defult方法）；而在继承中可以定义属性方法,变量,常量等。

### 3.4、继承与组合

#### 3.4.1、面向对象的复用技术

 复用性是面向对象技术带来的很棒的潜在好处之一。如果运用的好的话可以帮助我们节省很多开发时间，提升开发效率。但是，如果被滥用那么就可能产生很多难以维护的代码。

 作为一门面向对象开发的语言，代码复用是Java引人注意的功能之一。Java代码的复用有继承，组合以及代理三种具体的表现形式。本节将重点介绍继承复用和组合复用。

#### 3.4.2、继承

 继承（Inheritance）是一种联结类与类的层次模型。指的是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力，继承是类与类或者接口与接口之间最常见的关系；继承是一种is-a关系。

<img src="https://gitee.com/icecandy/imgbed/raw/master/Java/20201109204302.png" alt="image-20201109204301232" style="zoom:50%;" />

#### 3.4.3、组合

 组合(Composition)体现的是整体与部分、拥有的关系，即has-a的关系。

![image-20201109204348334](https://gitee.com/icecandy/imgbed/raw/master/Java/20201109204349.png)

#### 3.4.4、组合与继承的区别和联系

在`继承`结构中，父类的内部细节对于子类是可见的。所以我们通常也可以说通过继承的代码复用是一种`白盒式代码复用`。（如果基类的实现发生改变，那么派生类的实现也将随之改变。这样就导致了子类行为的不可预知性；）

`组合`是通过对现有的对象进行拼装（组合）产生新的、更复杂的功能。因为在对象之间，各自的内部细节是不可见的，所以我们也说这种方式的代码复用是`黑盒式代码复用`。（因为组合中一般都定义一个类型，所以在编译期根本不知道具体会调用哪个实现类的方法）

`继承`，在写代码的时候就要指名具体继承哪个类，所以，在`编译期`就确定了关系。（从基类继承来的实现是无法在运行期动态改变的，因此降低了应用的灵活性。）

`组合`，在写代码的时候可以采用面向接口编程。所以，类的组合关系一般在`运行期`确定。

#### 3.4.5、优缺点对比

|                           组合关系                           |                           继承关系                           |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
|   优点：不破坏封装，整体类与局部类之间松耦合，彼此相对独立   | 缺点：破坏封装，子类与父类之间紧密耦合，子类依赖于父类的实现，子类缺乏独立性 |
|                   优点：具有较好的可扩展性                   |     缺点：支持扩展，但是往往以增加系统结构的复杂度为代价     |
| 优点：支持动态组合。在运行时，整体对象可以选择不同类型的局部对象 |    缺点：不支持动态继承。在运行时，子类无法选择不同的父类    |
| 优点：整体类可以对局部类进行包装，封装局部类的接口，提供新的接口 |                 缺点：子类不能改变父类的接口                 |
|          缺点：整体类不能自动获得和局部类同样的接口          |                优点：子类能自动继承父类的接口                |
|      缺点：创建整体类的对象时，需要创建所有局部类的对象      |          优点：创建子类的对象时，无须创建父类的对象          |

#### 3.4.6、如何选择

 相信很多人都知道面向对象中有一个比较重要的原则『多用组合、少用继承』或者说『组合优于继承』。从前面的介绍已经优缺点对比中也可以看出，组合确实比继承更加灵活，也更有助于代码维护。所以，

> 建议在同样可行的情况下，优先使用组合而不是继承。
>
> 因为组合更安全，更简单，更灵活，更高效。

 注意，并不是说继承就一点用都没有了，前面说的是【在同样可行的情况下】。有一些场景还是需要使用继承的，或者是更适合使用继承。

> 继承要慎用，其使用场合仅限于你确信使用该技术有效的情况。一个判断方法是，问一问自己是否需要从新类向基类进行向上转型。如果是必须的，则继承是必要的。反之则应该好好考虑是否需要继承。《Java编程思想》
>
> 只有当子类真正是超类的子类型时，才适合用继承。换句话说，对于两个类A和B，只有当两者之间确实存在`is-a`关系的时候，类B才应该继承类A。《Effective Java》

## 四、多态

### 4.1、什么是多态

 是同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。如果按照这个概念来定义的话，那么多态应该是一种运行期的状态。

### 4.2、多态的必要条件

 为了实现运行期的多态，或者说是动态绑定，需要满足三个条件:

- 有类继承或者接口实现
- 子类要重写父类的方法
- 父类的引用指向子类的对象

 代码示例如下：

```java
public class Parent{

    public void call(){
        sout("im Parent");
    }
}

public class Son extends Parent{// 1.有类继承或者接口实现
    public void call(){// 2.子类要重写父类的方法
        sout("im Son");
    }
}

public class Daughter extends Parent{// 1.有类继承或者接口实现
    public void call(){// 2.子类要重写父类的方法
        sout("im Daughter");
    }
}

public class Test{

    public static void main(String[] args){
        Parent p = new Son(); //3.父类的引用指向子类的对象
        Parent p1 = new Daughter(); //3.父类的引用指向子类的对象
    }
}
```

 这样，就实现了多态，同样是Parent类的实例，p.call 调用的是Son类的实现、p1.call调用的是Daughter的实现。有人说，你自己定义的时候不就已经知道p是son，p1是Daughter了么。但是，有些时候你用到的对象并不都是自己声明的啊 。比如Spring 中的IOC出来的对象，你在使用的时候就不知道他是谁，或者说你可以不用关心他是谁。根据具体情况而定。

 另外，还有一种说法，包括维基百科也说明，多态还分为动态多态和静态多态。上面提到的那种动态绑定认为是动态多态，因为只有在运行期才能知道真正调用的是哪个类的方法。

 还有一种静态多态，一般认为Java中的函数重载是一种静态多态，因为他需要在编译期决定具体调用哪个方法、

 PS:关于这个动态静态的说法，我更偏向于重载和多态其实是无关的。

 但是也要看情况，普通场合，我会认为只有方法的重写算是多态，毕竟这是我的观点。但是如果在面试的时候，我“可能”会认为重载也算是多态，毕竟面试官也有他的观点。我会和面试官说：我认为，多态应该是一种运行期特性，Java中的重写是多态的体现。不过也有人提出重载是一种静态多态的想法，这个问题在StackOverflow等网站上有很多人讨论，但是并没有什么定论。我更加倾向于重载不是多态。

### 4.3、方法的重载（Overloading）和重写（Overriding）

#### 4.3.1、定义

- 重载(Overloading)：简单说，就是函数或者方法有同样的名称，但是参数列表不相同的情形，这样的同名不同参数的函数或者方法之间，互相称之为重载函数或者方法。
- 重写(Overriding)：指的是在Java的子类与父类中有两个名称、参数列表都相同的方法的情况。由于他们具有相同的方法签名，所以子类中的新方法将覆盖父类中原有的方法。

#### 4.3.2、重载 VS 重写

 关于重载和重写，应该知道以下几点：

> 1、重载是一个编译期概念、重写是一个运行期间概念。
> 2、重载遵循所谓“编译期绑定”，即在编译时根据参数变量的类型判断应该调用哪个方法。
> 3、重写遵循所谓“运行期绑定”，即在运行的时候，根据引用变量所指向的实际对象的类型来调用方法
> 4、因为在编译期已经确定调用哪个方法，所以重载并不是多态。而重写是多态。重载只是一种语言特性，是一种语法规则，与多态无关，与面向对象也无关。（注：严格来说，重载是编译时多态，即静态多态。但是，Java中提到的多态，在不特别说明的情况下都指动态多态）

#### 4.3.3、重写的例子

```java
class Dog{
    public void bark(){
        System.out.println("woof ");
    }
}
class Hound extends Dog{
    public void sniff(){
        System.out.println("sniff ");
    }

    public void bark(){
        System.out.println("bowl");
    }
}

public class OverridingTest{
    public static void main(String [] args){
        Dog dog = new Hound();
        dog.bark();
    }
}
```

 输出结果:

```java
bowl
```

 上面的例子中，dog对象被定义为Dog类型。在编译期，编译器会检查Dog类中是否有可访问的bark()方法，只要其中包含bark（）方法，那么就可以编译通过。在运行期，Hound对象被new出来，并赋值给dog变量，这时，JVM是明确的知道dog变量指向的其实是Hound对象的引用。所以，当dog调用bark()方法的时候，就会调用Hound类中定义的bark（）方法。这就是所谓的动态多态性。

#### 4.3.4、重写的条件

- 参数列表必须完全与被重写方法的相同；
- 返回类型必须完全与被重写方法的返回类型相同；
- 访问级别的限制性一定不能比被重写方法的强；
- 访问级别的限制性可以比被重写方法的弱；
- 重写方法一定不能抛出新的检查异常或比被重写的方法声明的检查异常更广泛的检查异常
- 重写的方法能够抛出更少或更有限的异常（也就是说，被重写的方法声明了异常，但重写的方法可以什么也不声明）
- 不能重写被标示为final的方法；
- 如果不能继承一个方法，则不能重写这个方法。

#### 4.3.5、重载的例子

```java
class Dog{
    public void bark(){
        System.out.println("woof ");
    }

    //overloading method
    public void bark(int num){
        for(int i=0; i<num; i++)
            System.out.println("woof ");
    }
}
```

 上面的代码中，定义了两个bark方法，一个是没有参数的bark方法，另外一个是包含一个int类型参数的bark方法。在编译期，编译期可以根据方法签名（方法名和参数情况）情况确定哪个方法被调用。

#### 4.3.6、重载的条件

- 被重载的方法必须改变参数列表；
- 被重载的方法可以改变返回类型；
- 被重载的方法可以改变访问修饰符；
- 被重载的方法可以声明新的或更广的检查异常；
- 方法能够在同一个类中或者在一个子类中被重载。

#### 4.3.7、向上转型与向下转型

![image-20201109205518815](https://gitee.com/icecandy/imgbed/raw/master/Java/20201109205520.png)